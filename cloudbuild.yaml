steps:
  # 1Ô∏è‚É£ Instalar Node y dependencias (Solo npm ci)
  - name: 'node:22.17-bullseye'
    id: 'Install dependencies'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Installing dependencies..."
        # Usa 'npm ci' para instalaciones limpias en CI/CD
        npm ci

  # 2Ô∏è‚É£ Detectar apps afectadas (Instalamos jq aqu√≠ y usamos grep para filtrar E2E)
  - name: 'node:22.17-bullseye'
    id: 'Affected apps'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Detecting affected projects using modern Nx command..."
        
        # ‚ö†Ô∏è INSTALACI√ìN CR√çTICA: Instalar jq en este mismo paso antes de usarlo.
        apt-get update && apt-get install -y jq
        
        # Nuevo comando Nx (post-v19):
        # 1. Obtiene los proyectos afectados.
        # 2. Usa jq para obtener la lista plana de nombres.
        # 3. Usa grep -v para EXCLUIR cualquier nombre que termine con '-e2e'.
        npx nx show projects --affected --json --target=build --base=HEAD~1 --head=HEAD --type=app | \
          jq -r '.[]' | grep -v -- "-e2e$" > ./affected_apps.txt
        
        # Verificar si el archivo est√° vac√≠o. El flag -s verifica si el archivo existe y no est√° vac√≠o.
        if [ ! -s ./affected_apps.txt ]; then
          echo "No apps affected. Exiting this step."
          # Si no hay apps, creamos un archivo vac√≠o para que los siguientes pasos lo ignoren.
          echo "" > ./affected_apps.txt
          exit 0
        fi
        
        echo "Detected apps:"
        cat ./affected_apps.txt

  # 3Ô∏è‚É£ Construir y Pushear solo las im√°genes de Docker de las apps afectadas
  # Utilizamos el builder 'docker' para operaciones de im√°genes.
  # Usamos 'while read' para evitar la ambig√ºedad de la variable $AFFECTED_APPS
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build and push images'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Leer la lista de aplicaciones del archivo compartido l√≠nea por l√≠nea
        if [ ! -s ./affected_apps.txt ]; then
          echo "No affected apps found in file. Skipping build/push."
          exit 0
        fi
        
        echo "Starting build and push process..."
        
        # Leemos el archivo l√≠nea por l√≠nea, la variable 'app' se define localmente en el bucle.
        cat ./affected_apps.txt | while read app; do
          if [ -z "$app" ]; then continue; fi # Saltar l√≠neas vac√≠as
          
          echo "üê≥ Building and pushing $app..."
          # Construye la imagen, asumiendo que el Dockerfile est√° en ./apps/$app
          docker build -t gcr.io/$PROJECT_ID/$app ./apps/$app
          # Sube la imagen a Google Container Registry
          docker push gcr.io/$PROJECT_ID/$app
        done
    waitFor: ['Affected apps']

  # 4Ô∏è‚É£ Desplegar las apps afectadas en Cloud Run
  # ESENCIAL: Usamos el builder 'gcloud' porque este s√≠ incluye el comando 'gcloud'.
  # Tambi√©n usando 'while read' para evitar el problema de sustituci√≥n.
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Deploy affected apps'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Leer la lista de aplicaciones
        if [ ! -s ./affected_apps.txt ]; then
          echo "No affected apps found in file. Skipping deployment."
          exit 0
        fi
        
        echo "Starting deployment process..."

        # Leemos el archivo l√≠nea por l√≠nea.
        cat ./affected_apps.txt | while read app; do
          if [ -z "$app" ]; then continue; fi # Saltar l√≠neas vac√≠as
          
          echo "üöÄ Deploying $app to Cloud Run..."
          gcloud run deploy $app \
            --image=gcr.io/$PROJECT_ID/$app \
            --platform=managed \
            --region=us-central1 \
            --quiet \
            --project=$PROJECT_ID 
        done
    waitFor: ['Build and push images'] # Esperamos a que las im√°genes est√©n listas

# 5Ô∏è‚É£ Opciones generales de la build
options:
  logging: CLOUD_LOGGING_ONLY

# 6Ô∏è‚É£ Timeout opcional
timeout: "1800s"