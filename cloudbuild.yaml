steps:
  # 1Ô∏è‚É£ PROFUNDIZAR EL CLONE: Necesario para que Nx pueda comparar HEAD con HEAD~1
  - name: 'gcr.io/cloud-builders/git'
    id: 'Deepen Git History'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Deepening Git history to allow comparison with HEAD~1..."
        # El valor --depth=2 asegura que el commit actual (HEAD) y el anterior (HEAD~1) est√©n disponibles.
        # Esto permite a Nx realizar la comparaci√≥n.
        git fetch origin $(git rev-parse HEAD) --depth=2

  # 2Ô∏è‚É£ Instalar Node y dependencias (Solo npm ci)
  - name: 'node:22.17-bullseye'
    id: 'Install dependencies'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Installing dependencies..."
        # Usa 'npm ci' para instalaciones limpias en CI/CD
        npm ci
    waitFor: ['Deepen Git History']

  # 3Ô∏è‚É£ Detectar apps afectadas (Instalamos jq aqu√≠ y usamos grep para filtrar E2E)
  - name: 'node:22.17-bullseye'
    id: 'Affected apps'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Configurar pipefail para que si cualquier comando en el pipe falla, el paso falle inmediatamente.
        set -e -o pipefail

        echo "Detecting affected projects using modern Nx command..."
        
        # ‚ö†Ô∏è INSTALACI√ìN CR√çTICA: Instalar jq en este mismo paso antes de usarlo.
        apt-get update && apt-get install -y jq
        
        # Nuevo comando Nx (post-v19):
        # 1. Obtiene los proyectos afectados.
        # 2. Usa jq para obtener la lista plana de nombres.
        # 3. Usa grep -v para EXCLUIR cualquier nombre que termine con '-e2e'.
        npx nx show projects --affected --json --target=build --base=HEAD~1 --head=HEAD --type=app | \
          jq -r '.[]' | grep -v -- "-e2e$" > ./affected_apps.txt
        
        # Despu√©s de que el pipe finaliza con √©xito, podemos verificar el archivo.
        
        # Verificar si el archivo est√° vac√≠o. El flag -s verifica si el archivo existe y no est√° vac√≠o.
        if [ ! -s ./affected_apps.txt ]; then
          echo "No apps affected. Exiting this step."
          # Si no hay apps, creamos un archivo vac√≠o para que los siguientes pasos lo ignoren.
          echo "" > ./affected_apps.txt
          exit 0
        fi
        
        echo "Detected apps:"
        cat ./affected_apps.txt
    waitFor: ['Install dependencies']

  # 4Ô∏è‚É£ Construir y Pushear solo las im√°genes de Docker de las apps afectadas
  # Normalizaci√≥n a min√∫sculas y eliminaci√≥n de caracteres no v√°lidos.
  - name: 'gcr.io/cloud-builders/docker'
    id: 'Build and push images'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Leer la lista de aplicaciones del archivo compartido l√≠nea por l√≠nea
        if [ ! -s ./affected_apps.txt ]; then
          echo "No affected apps found in file. Skipping build/push."
          exit 0
        fi
        
        echo "Starting build and push process..."
        
        cat ./affected_apps.txt | while read app; do
          if [ -z "$app" ]; then continue; fi # Saltar l√≠neas vac√≠as
          
          # üö® NORMALIZACI√ìN COMPLETA (Slugification)
          # 1. Convertir a min√∫sculas. 
          # 2. Reemplazar '/' por '-'. 
          # 3. Eliminar '@'.
          app_lc=$(echo "$app" | tr '[:upper:]' '[:lower:]' | sed -e 's|/|-|g' -e 's|@||g')
          
          echo "üê≥ Building and pushing $app (as $app_lc)..."
          # Construye la imagen. La carpeta de c√≥digo fuente es el nombre original ($app).
          docker build -t gcr.io/$PROJECT_ID/$app_lc ./apps/$app
          # Sube la imagen con el nombre normalizado ($app_lc).
          docker push gcr.io/$PROJECT_ID/$app_lc
        done
    waitFor: ['Affected apps']

  # 5Ô∏è‚É£ Desplegar las apps afectadas en Cloud Run
  # Usamos el nombre normalizado ($app_lc) para el servicio de Cloud Run.
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'Deploy affected apps'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Leer la lista de aplicaciones
        if [ ! -s ./affected_apps.txt ]; then
          echo "No affected apps found in file. Skipping deployment."
          exit 0
        fi
        
        echo "Starting deployment process..."

        # Leemos el archivo l√≠nea por l√≠nea.
        cat ./affected_apps.txt | while read app; do
          if [ -z "$app" ]; then continue; fi # Saltar l√≠neas vac√≠as
          
          # üö® NORMALIZACI√ìN COMPLETA (Slugification)
          # 1. Convertir a min√∫sculas. 
          # 2. Reemplazar '/' por '-'. 
          # 3. Eliminar '@'.
          app_lc=$(echo "$app" | tr '[:upper:]' '[:lower:]' | sed -e 's|/|-|g' -e 's|@||g')
          
          echo "üöÄ Deploying $app_lc to Cloud Run..."
          # Despliega con el nombre normalizado y la imagen normalizada.
          gcloud run deploy $app_lc \
            --image=gcr.io/$PROJECT_ID/$app_lc \
            --platform=managed \
            --region=us-central1 \
            --quiet \
            --project=$PROJECT_ID 
        done
    waitFor: ['Build and push images'] # Esperamos a que las im√°genes est√©n listas

# 6Ô∏è‚É£ Opciones generales de la build
options:
  logging: CLOUD_LOGGING_ONLY

# 7Ô∏è‚É£ Timeout opcional
timeout: "1800s"